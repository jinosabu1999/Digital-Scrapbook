/// <reference lib="webworker" />

import { clientsClaim } from "workbox-core"
import { ExpirationPlugin } from "workbox-expiration"
import { precacheAndRoute } from "workbox-precaching"
import { registerRoute } from "workbox-routing"
import { StaleWhileRevalidate, CacheFirst } from "workbox-strategies"

declare const self: ServiceWorkerGlobalScope

clientsClaim()

// Precache all of the assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST)

// Cache the underlying font files with a cache-first strategy for 1 year
registerRoute(
  ({ url }) => url.origin === "https://fonts.gstatic.com",
  new CacheFirst({
    cacheName: "google-fonts-webfonts",
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 365,
        maxEntries: 30,
      }),
    ],
  }),
)

// Cache images with a cache-first strategy
registerRoute(
  ({ request }) => request.destination === "image",
  new CacheFirst({
    cacheName: "images",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  }),
)

// Use a stale-while-revalidate strategy for all other requests
registerRoute(
  ({ request }) =>
    request.destination === "style" || request.destination === "script" || request.destination === "worker",
  new StaleWhileRevalidate({
    cacheName: "assets",
  }),
)

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting()
  }
})

// Background sync for offline changes
self.addEventListener("sync", (event) => {
  if (event.tag === "sync-memories") {
    event.waitUntil(syncMemories())
  }
})

async function syncMemories() {
  const db = await openDB()
  const tx = db.transaction("offlineChanges", "readonly")
  const store = tx.objectStore("offlineChanges")
  const changes = await store.getAll()

  for (const change of changes) {
    try {
      // Process each change
      await fetch("/api/sync", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(change),
      })

      // Remove from offline store after successful sync
      const deleteTx = db.transaction("offlineChanges", "readwrite")
      const deleteStore = deleteTx.objectStore("offlineChanges")
      await deleteStore.delete(change.id)
    } catch (error) {
      console.error("Failed to sync change:", error)
    }
  }
}

async function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("chronocapsule-offline", 1)

    request.onupgradeneeded = (event) => {
      const db = request.result
      if (!db.objectStoreNames.contains("offlineChanges")) {
        db.createObjectStore("offlineChanges", { keyPath: "id" })
      }
    }

    request.onsuccess = () => resolve(request.result)
    request.onerror = () => reject(request.error)
  })
}

